<!DOCTYPE html>
<html>
<head>
    <title>Shatranj - Ancient Chess</title>
    <style>
        * { box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; margin: 0; background: #1a1a1a; color: #fff; }
        
        .welcome-screen { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        .welcome-screen h1 { font-size: 48px; margin-bottom: 20px; }
        .welcome-screen p { font-size: 18px; margin-bottom: 40px; text-align: center; max-width: 600px; }
        
        .mode-selection { display: flex; gap: 30px; margin-bottom: 30px; }
        .mode-card { background: #2d2d2d; padding: 30px; border-radius: 12px; cursor: pointer; transition: all 0.3s; min-width: 200px; text-align: center; }
        .mode-card:hover { background: #3d3d3d; transform: translateY(-5px); }
        .mode-card h3 { margin: 0 0 15px 0; font-size: 24px; }
        .mode-card p { margin: 0; opacity: 0.8; }
        
        .side-selection { display: none; margin-top: 20px; }
        .side-btn { background: #4ecdc4; color: #fff; border: none; padding: 15px 30px; margin: 10px; border-radius: 8px; cursor: pointer; font-size: 16px; }
        .side-btn:hover { background: #45b7aa; }
        
        .game-screen { display: none; flex: 1; }
        .container { display: flex; height: 100vh; }
        .board-section { flex: 1; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .sidebar { width: 350px; background: #2d2d2d; padding: 20px; overflow-y: auto; }
        
        .board-container { position: relative; padding-left: 30px; padding-bottom: 30px; }
        .board { display: grid; grid-template-columns: repeat(8, 60px); border: 3px solid #444; }
        .square { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; font-size: 32px; cursor: pointer; transition: all 0.2s; }
        .light { background: #f0d9b5; color: #333; }
        .dark { background: #b58863; color: #333; }
        .selected { box-shadow: inset 0 0 0 4px #ff6b6b !important; }
        .move-option { box-shadow: inset 0 0 0 3px #4ecdc4 !important; }
        
        .coords { position: absolute; color: #888; font-size: 12px; font-weight: bold; pointer-events: none; }
        .rank-coord { left: 5px; width: 20px; height: 60px; display: flex; align-items: center; justify-content: center; }
        .file-coord { bottom: 5px; width: 60px; height: 20px; display: flex; align-items: center; justify-content: center; }
        
        .controls { margin: 20px 0; }
        .btn { background: #4ecdc4; color: #fff; border: none; padding: 12px 20px; margin: 5px; border-radius: 6px; cursor: pointer; font-size: 14px; }
        .btn:hover { background: #45b7aa; }
        
        .game-info { background: #333; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .status { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
        
        .move-list { background: #333; border-radius: 8px; padding: 15px; max-height: 300px; overflow-y: auto; }
        .move-item { padding: 5px 10px; margin: 2px 0; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="welcome-screen" id="welcomeScreen">
        <h1>üèõÔ∏è Shatranj</h1>
        <p>Experience the ancient predecessor of chess. Shatranj features different piece movements including the Ferz (one square diagonally) and Alfil (jumps two squares diagonally).</p>
        
        <div class="mode-selection">
            <div class="mode-card" onclick="selectMode('playground')">
                <h3>üéØ Playground</h3>
                <p>Explore moves and practice freely</p>
            </div>
            <div class="mode-card" onclick="selectMode('computer')">
                <h3>ü§ñ vs Computer</h3>
                <p>Play against the engine</p>
            </div>
        </div>
        
        <div class="side-selection" id="sideSelection">
            <p>Choose your side:</p>
            <button class="side-btn" onclick="startGame('white')">Play as White</button>
            <button class="side-btn" onclick="startGame('black')">Play as Black</button>
            <div style="margin-top: 20px;">
                <label style="color: #fff;">Search Mode: </label>
                <select id="searchMode" onchange="toggleSearchOptions()" style="padding: 8px; border-radius: 4px; background: #444; color: #fff; border: none; margin-bottom: 10px;">
                    <option value="time">Time-based</option>
                    <option value="depth">Depth-based</option>
                </select>
                <div id="timeOptions">
                    <label style="color: #fff;">Think Time: </label>
                    <select id="timeSelect" style="padding: 8px; border-radius: 4px; background: #444; color: #fff; border: none;">
                        <option value="1">1 second</option>
                        <option value="2">2 seconds</option>
                        <option value="3" selected>3 seconds</option>
                        <option value="5">5 seconds</option>
                        <option value="10">10 seconds</option>
                        <option value="30">30 seconds</option>
                        <option value="60">60 seconds</option>
                    </select>
                </div>
                <div id="depthOptions" style="display: none;">
                    <label style="color: #fff;">Search Depth: </label>
                    <select id="depthSelect" style="padding: 8px; border-radius: 4px; background: #444; color: #fff; border: none;">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3" selected>3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8">8</option>
                        <option value="10">10</option>
                        <option value="12">12</option>
                        <option value="15">15</option>
                        <option value="20">20</option>
                        <option value="25">25</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="game-screen" id="gameScreen">
        <div class="container">
            <div class="board-section">
                <div class="controls">
                    <button class="btn" onclick="showWelcome()">‚Üê Menu</button>
                    <button class="btn" onclick="newGame()">New Game</button>
                    <button class="btn" onclick="flipBoard()">Flip</button>
                    <button class="btn" onclick="takeBack()">Take Back</button>
                </div>
                
                <div class="board-container">
                    <div class="board" id="board"></div>
                    <div class="coords" id="coords"></div>
                </div>
            </div>
            
            <div class="sidebar">
                <div class="game-info">
                    <div class="status" id="status">White to move</div>
                    <div id="modeInfo">Mode: Playground</div>
                </div>
                
                <div class="move-list">
                    <h3>Move History</h3>
                    <div id="moveHistory"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="movedump.js"></script>
    <script src="shatranj_simple_uci.js"></script>
    <script>
        let board = {};
        let selectedSquare = null;
        let availableMoves = [];
        let gameMode = 'playground';
        let playerSide = 'white';
        let currentPlayer = 'w';
        let moveHistory = [];
        let gameHistory = [];
        let flipped = false;
        let moveDumpReady = false;
        let uciEngine = null;
        let computerThinkTime = 3;
        let computerSearchDepth = 3;
        let searchMode = 'time';
        let isComputerThinking = false;

        const pieceSymbols = {
            'P': '‚ôô', 'H': '‚ôò', 'F': '‚ôó', 'R': '‚ôñ', 'V': '‚ôï', 'S': '‚ôî',
            'p': '‚ôü', 'h': '‚ôû', 'f': '‚ôù', 'r': '‚ôú', 'v': '‚ôõ', 's': '‚ôö'
        };

        const startingFEN = 'rhfvsfhr/pppppppp/8/8/8/8/PPPPPPPP/RHFVSFHR w - - 0 1';

        async function initModules() {
            try {
                await MoveDump({ print: () => {}, printErr: () => {} });
                moveDumpReady = true;
                console.log('MoveDump ready');
            } catch (e) {
                console.error('Failed to load modules:', e);
            }
        }

        function selectMode(mode) {
            gameMode = mode;
            if (mode === 'computer') {
                document.getElementById('sideSelection').style.display = 'block';
            } else {
                startGame('white');
            }
        }

        function toggleSearchOptions() {
            searchMode = document.getElementById('searchMode').value;
            document.getElementById('timeOptions').style.display = searchMode === 'time' ? 'block' : 'none';
            document.getElementById('depthOptions').style.display = searchMode === 'depth' ? 'block' : 'none';
        }

        function startGame(side) {
            playerSide = side;
            if (gameMode === 'computer') {
                searchMode = document.getElementById('searchMode').value;
                if (searchMode === 'time') {
                    computerThinkTime = parseInt(document.getElementById('timeSelect').value);
                } else {
                    computerSearchDepth = parseInt(document.getElementById('depthSelect').value);
                }
            }
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'flex';
            newGame();
        }

        function showWelcome() {
            document.getElementById('welcomeScreen').style.display = 'flex';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('sideSelection').style.display = 'none';
        }

        function parseFEN(fen) {
            const parts = fen.split(' ');
            const rows = parts[0].split('/');
            const newBoard = {};
            
            for (let rank = 0; rank < 8; rank++) {
                let file = 0;
                for (let char of rows[rank]) {
                    if (isNaN(char)) {
                        newBoard[fileRankToSquare(file, 7-rank)] = char;
                        file++;
                    } else {
                        file += parseInt(char);
                    }
                }
            }
            return newBoard;
        }

        function fileRankToSquare(file, rank) {
            return String.fromCharCode(97 + file) + (rank + 1);
        }

        function createBoard() {
            const boardEl = document.getElementById('board');
            const coordsEl = document.getElementById('coords');
            boardEl.innerHTML = '';
            coordsEl.innerHTML = '';
            
            for (let i = 0; i < 8; i++) {
                const rankCoord = document.createElement('div');
                rankCoord.className = 'coords rank-coord';
                rankCoord.style.top = `${i * 60 + 30}px`;
                rankCoord.textContent = flipped ? i + 1 : 8 - i;
                coordsEl.appendChild(rankCoord);
                
                const fileCoord = document.createElement('div');
                fileCoord.className = 'coords file-coord';
                fileCoord.style.left = `${i * 60 + 30}px`;
                fileCoord.textContent = String.fromCharCode(97 + (flipped ? 7 - i : i));
                coordsEl.appendChild(fileCoord);
            }
            
            for (let rank = 0; rank < 8; rank++) {
                for (let file = 0; file < 8; file++) {
                    const displayRank = flipped ? rank : 7 - rank;
                    const displayFile = flipped ? 7 - file : file;
                    const square = fileRankToSquare(displayFile, displayRank);
                    const squareEl = document.createElement('div');
                    squareEl.className = `square ${(file + rank) % 2 === 0 ? 'light' : 'dark'}`;
                    squareEl.id = square;
                    squareEl.onclick = () => handleSquareClick(square);
                    
                    const piece = board[square];
                    if (piece) {
                        squareEl.textContent = pieceSymbols[piece] || piece;
                    }
                    
                    boardEl.appendChild(squareEl);
                }
            }
        }

        async function getMoves() {
            if (!moveDumpReady) return [];
            
            return new Promise((resolve) => {
                const fen = getCurrentFEN();
                const moves = [];
                
                MoveDump({
                    print: (text) => {
                        if (text.match(/^[a-h][1-8]-[a-h][1-8]$/)) {
                            moves.push(text.trim());
                        }
                    },
                    printErr: () => {},
                    arguments: [fen]
                }).then(() => resolve(moves)).catch(() => resolve(moves));
            });
        }
        
        async function getComputerMove() {
            return new Promise((resolve) => {
                const moveSeq = gameHistory.map(m => {
                    const parts = m.split('-');
                    return parts[0] + parts[1].replace(/x.*/, '');
                }).join(' ');
                
                const worker = new Worker('uci-worker.js');
                const startTime = Date.now();
                
                if (searchMode === 'time') {
                    console.log(`[Computer] Asking engine for position: ${moveSeq || 'startpos'} (time: ${computerThinkTime}s)`);
                    worker.postMessage({ moveSeq, thinkTime: computerThinkTime });
                } else {
                    console.log(`[Computer] Asking engine for position: ${moveSeq || 'startpos'} (depth: ${computerSearchDepth})`);
                    worker.postMessage({ moveSeq, depth: computerSearchDepth });
                }
                
                worker.onmessage = (e) => {
                    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                    console.log(`[Computer] Received move after ${elapsed}s:`, e.data);
                    worker.terminate();
                    resolve(e.data);
                };
                
                worker.onerror = (err) => {
                    console.error('[Computer] Worker error:', err);
                    worker.terminate();
                    resolve(null);
                };
                
                const timeout = searchMode === 'time' ? computerThinkTime + 5 : 300;
                setTimeout(() => {
                    console.warn(`[Computer] Timeout after ${timeout}s, terminating worker`);
                    worker.terminate();
                    resolve(null);
                }, timeout * 1000);
            });
        }
        
        function getCurrentFEN() {
            let fen = '';
            for (let rank = 7; rank >= 0; rank--) {
                let empty = 0;
                for (let file = 0; file < 8; file++) {
                    const square = fileRankToSquare(file, rank);
                    const piece = board[square];
                    if (piece) {
                        if (empty > 0) {
                            fen += empty;
                            empty = 0;
                        }
                        fen += piece;
                    } else {
                        empty++;
                    }
                }
                if (empty > 0) fen += empty;
                if (rank > 0) fen += '/';
            }
            return `${fen} ${currentPlayer} - - 0 1`;
        }

        async function handleSquareClick(square) {
            if (isComputerThinking) return;
            
            const piece = board[square];
            
            if (selectedSquare && availableMoves.some(m => m.split('-')[1] === square)) {
                await makeMove(selectedSquare, square);
                
                if (gameMode === 'computer') {
                    const isComputerTurn = (playerSide === 'white' && currentPlayer === 'b') ||
                                          (playerSide === 'black' && currentPlayer === 'w');
                    if (isComputerTurn) {
                        setTimeout(makeComputerMove, 500);
                    }
                }
                return;
            }
            
            if (selectedSquare === square) {
                clearSelection();
                return;
            }
            
            if (piece) {
                const isWhitePiece = piece === piece.toUpperCase();
                const isCurrentPlayerPiece = (currentPlayer === 'w' && isWhitePiece) || (currentPlayer === 'b' && !isWhitePiece);
                
                const canSelect = gameMode === 'playground' || 
                                 (gameMode === 'computer' && isCurrentPlayerPiece && 
                                  ((playerSide === 'white' && currentPlayer === 'w') ||
                                   (playerSide === 'black' && currentPlayer === 'b')));
                
                if (canSelect && isCurrentPlayerPiece) {
                    await selectSquare(square);
                } else {
                    clearSelection();
                }
            } else {
                clearSelection();
            }
        }

        async function selectSquare(square) {
            clearSelection();
            selectedSquare = square;
            document.getElementById(square).classList.add('selected');
            
            const moves = await getMoves();
            availableMoves = moves.filter(m => m.startsWith(square + '-'));
            
            availableMoves.forEach(move => {
                const toSquare = move.split('-')[1];
                const toEl = document.getElementById(toSquare);
                if (toEl) toEl.classList.add('move-option');
            });
        }

        function clearSelection() {
            document.querySelectorAll('.selected, .move-option').forEach(el => {
                el.classList.remove('selected', 'move-option');
            });
            selectedSquare = null;
            availableMoves = [];
        }

        async function makeMove(from, to) {
            const piece = board[from];
            const captured = board[to];
            
            moveHistory.push({ from, to, piece, captured });
            gameHistory.push(`${from}-${to}${captured ? 'x' : ''}`);
            
            board[to] = piece;
            delete board[from];
            currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            
            clearSelection();
            createBoard();
            updateDisplay();
        }

        async function makeComputerMove() {
            if (isComputerThinking) return;
            isComputerThinking = true;
            
            const move = await getComputerMove();
            if (move) {
                await makeMove(move.from, move.to);
            }
            
            isComputerThinking = false;
        }

        function updateDisplay() {
            const statusEl = document.getElementById('status');
            statusEl.textContent = `${currentPlayer === 'w' ? 'White' : 'Black'} to move`;
            
            const modeInfo = document.getElementById('modeInfo');
            if (gameMode === 'playground') {
                modeInfo.textContent = 'Mode: Playground';
            } else {
                const isPlayerTurn = (playerSide === 'white' && currentPlayer === 'w') || 
                                    (playerSide === 'black' && currentPlayer === 'b');
                const searchText = searchMode === 'time' ? `${computerThinkTime}s/move` : `depth ${computerSearchDepth}`;
                modeInfo.textContent = `Mode: vs Computer (${searchText}, You: ${playerSide}) - ${isPlayerTurn ? 'Your turn' : 'Computer thinking...'}`;
            }
            
            const historyEl = document.getElementById('moveHistory');
            historyEl.innerHTML = gameHistory.map((move, i) => 
                `<div class="move-item">${Math.floor(i/2) + 1}${i % 2 === 0 ? '.' : '...'} ${move}</div>`
            ).join('');
        }

        function newGame() {
            board = parseFEN(startingFEN);
            currentPlayer = 'w';
            moveHistory = [];
            gameHistory = [];
            isComputerThinking = false;
            clearSelection();
            createBoard();
            updateDisplay();
            
            if (gameMode === 'computer' && playerSide === 'black') {
                setTimeout(makeComputerMove, 500);
            }
        }

        function flipBoard() {
            flipped = !flipped;
            createBoard();
        }

        function takeBack() {
            if (moveHistory.length === 0) return;
            
            const movesToTakeBack = gameMode === 'computer' ? Math.min(2, moveHistory.length) : 1;
            
            for (let i = 0; i < movesToTakeBack; i++) {
                if (moveHistory.length === 0) break;
                
                const lastMove = moveHistory.pop();
                gameHistory.pop();
                
                board[lastMove.from] = lastMove.piece;
                if (lastMove.captured) {
                    board[lastMove.to] = lastMove.captured;
                } else {
                    delete board[lastMove.to];
                }
                currentPlayer = currentPlayer === 'w' ? 'b' : 'w';
            }
            
            clearSelection();
            createBoard();
            updateDisplay();
        }

        initModules();
    </script>
</body>
</html>
